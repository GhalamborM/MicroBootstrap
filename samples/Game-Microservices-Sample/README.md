**Introduce the sample**
----------------
In this sample we have a simple microservices project based on our [MicroBootstrap](https://github.com/mehdihadeli/MicroBootstrap/tree/master/src/MicroBootstrap) package which contains 3 micro-services: 
* [Game.APIGateway](https://github.com/mehdihadeli/MicroBootstrap/tree/master/samples/Game-Microservices-Sample/Game.APIGateway)
* [Game.Services.EventProcessor](https://github.com/mehdihadeli/MicroBootstrap/tree/master/samples/Game-Microservices-Sample/Game.Services.EventProcessor)
* [Game.Services.Messaging](https://github.com/mehdihadeli/MicroBootstrap/tree/master/samples/Game-Microservices-Sample/Game.Services.Messaging)
 
 
 ![Game](https://github.com/mehdihadeli/MicroBootstrap/blob/master/samples/Game-Microservices-Sample/image.jpg?raw=true)
 
 `Game.APIGateway` is our API Gateway of our microservices and it will manage and route our request to appropriate end-points in other microservices. in this API Gateway we use different technologies like [Consul](https://www.consul.io/), [Fabio](https://fabiolb.net/) for service discovery and load-balancing (we can turn them off in our appsettings when we use Kubernetes) and [RabbitMQ](https://www.rabbitmq.com/) for our message broker, [RESTEeas](https://github.com/canton7/RestEase) for Http calls, [Jaeger](https://www.jaegertracing.io/) for distributed tracing, [Seq](https://datalust.co/) and [Serilog](https://serilog.net/) for logging purpose, [Vault](https://www.vaultproject.io/) for security and key management, [Prometheus](https://prometheus.io/) for monitoring and [MongoDB](https://www.mongodb.com/) and [Redis](https://redis.io/) for our storage system. this service will be available in this address [http://localhost:7000](http://localhost:7000).
 
 `Game.Services.EventProcessor` is a service for processing commands that send on the message broker. for example in this sample in our `API Gateway` we send an `AddGameEventSource` command to the message broker for creating a game event source. `EventProcessor` service that subscribed to this command `AddGameEventSource` consumes this command from the message broker and will execute its command handler for this command and store this game event source in MongoDB. then this handler in the final step will publish a `GameEventSourceAdded` event to message broker. this service will be available in this address [http://localhost:7001](http://localhost:7001)
 
 `Game.Services.Messaging` is a service that uses SignalR and consumes `GameEventSourceAdded` event from the message broker. after `Messaging` service gets an event from broker it executes its handler and will store the incoming game-event-source data in messaging microservice database internally. why we do this? because we want to reduce coupling between microservices and we want to reduce internal and external http calls because they will create a temporal coupling between microservices or in some situations other services might be down and we store our data in our microservice and we don't have to call any external microservices. then we calculate `leader-board-info` that contains Rank, Score, BehindPlayerInRank, AheadPlayerInRank for our specific user that in our case is userId property of `GameEventSourceAdded` object. after calculating leader-board-info for our user we send it to our signalr output in this address [http://localhost:7002/signalr/index.html](http://localhost:7002/signalr/index.html). the result is something like this:
 
 ![user-leader-board-info](https://github.com/mehdihadeli/MicroBootstrap/blob/master/samples/Game-Microservices-Sample/user-leader-board-info.jpg?raw=true)
 
